# 函数表达式

## 递归

函数内部通过名字调用自身的情况

arguments.callee 是一个指向正在执行的函数的指针，因此可以它来实现对函数的递归调用，

function factorial(num){
if (num <= 1){
return 1;
} else {
return num \* arguments.callee(num-1);
}
}

## 闭包

闭包是指有权访问另一个函数作用域中的变量的函数

由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。

#### 闭包与变量


## 模仿块级作用域
通过闭包模仿块级作用域
立即执行函数 
(function(){
// 函数内部作用域  为块级作用域
})()


## 私有变量
...

#小结
JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，
从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结
了函数表达式的特点。
 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表
达式也叫做匿名函数。
 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可
能会发生变化。
当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理
如下。
 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
使用闭包可以在 JavaScript 中模仿块级作用域（JavaScript 本身没有块级作用域的概念），要点如下。
 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外
部作用域）中的变量。
闭包还可以用于在对象中创建私有变量，相关概念和要点如下。
 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公
有方法可以访问在包含作用域中定义的变量。
 有权访问私有变量的公有方法叫做特权方法。
 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强
的模块模式来实现单例的特权方法。
JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为
创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。
