# Object 类型
创建 Object 实例的方式有两种
var person = new Object; // 构造函数 
var person = {  // 对象字面量
    name:'yoke';
}

访问属性的方法
    .属性名
    或者['属性名']
    方括号可以访问 动态 变化的属性名 和一些特殊的不能 . 调用的一个属性名 

# Array 类型

js中的数组每一项可以保存任何类型的数据
大小长度动态调整
var colors = new Array();
var colors = ['red','blue']
在使用数组字面量表示法时  最后一个数据后面不要加 , 不同的浏览器可能会创建出不同长度的数组

colors[i] 不仅可以获取值修改值 还能用来新增
数组也能通过减少 长度来删除 数据

### 检测数组 
 instanceof Array
 它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。
为了解决这个问题，ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到是不是数组
Array.isArray(value)
### 转换方法
所有对象都具有 toLocaleString()、toString()和 valueOf()方法
调用数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
使用 join()方法，则可以使用不同的分隔符来构建这个字符串
join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。
重写了 toString 方法

### 栈方法  
栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度
pop()方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项

### 队列方法
而队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）

结合使用 shift()和 push()方法，可以像使用队列一样使用数组
是 shift()，它能够移除数组中的第一个项并返回该项

unshift()和 pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项
unshift()在数组的其那段添加项  返回值为 length

### 重排序方法
reverse()和 sort()
reverse()会反转数组项的顺序

sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串

sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面
过返回一个小于零、等于零或大于零的值来影响排序结果 返回大于1  及要交换位置

### 操作方法
concat()方法可以基于当前数组中的所有项创建一个新数组
先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组

slice()它能够基于当前数组中的一或多个项创建一个新数组
slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项 
* 如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用 slice(-2,-1)与调用 slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。

##### splice() 改变原数组

删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项  //返回值是删除的那一项

插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,"red","green")会从当前数组的位置 2 开始插入字符串"red"和"green"。 // 返回为空

替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,"red","green")会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串"red"和"green"。 // 返回删除的项

### 位置方法
了两个位置方法：indexOf()和 lastIndexOf()
这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找
这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1  比较时做的是 === 操作
查到返回索引下标  只返回第一个查找到的值

### 迭代方法

每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身

// 以下方法都不会修改原数组
every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true
filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true

every()和 some()  都是返回 ture or false every是每个都为true  some 为有一个为ture
filter 过滤 给定限制条件进行过滤
map 对每个数据进行操作
foreach  对数组中的数据经行一次for循环

### 归并方法
reduce()和 reduceRight()
reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项
接收 4 个参数：前一个值、当前值、项的索引和数组对象。
# Date 类型
创建一个日期对象
var now = new Date();
Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数   会因为不同地区的浏览器有差距

Date.UTC()方法同样也返回表示日期的毫秒数 。Date.UTC()的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天
（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。
Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数
### 继承的方法
两个时间的值可以直接拿来进行比较
### 日期格式化方法
    toDateString()——以特定于实现的格式显示星期几、月、日和年；
    toTimeString()——以特定于实现的格式显示时、分、秒和时区；
    toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
    toUTCString()——以特定于实现的格式完整的 UTC 日期。
与 toLocaleString()和 toString()方法一样，以上这些字符串格式方法的输出也是因浏览器
而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息

### 日期/时间组件方法

# RegExp 类型
g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项

正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]}

创建正则表达式的方式是使用RegExp 构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串
### RegExp实例属性

RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
    global：布尔值，表示是否设置了 g 标志。
    ignoreCase：布尔值，表示是否设置了 i 标志。
    lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。
    multiline：布尔值，表示是否设置了 m 标志。
    source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中

### RegExp实例方法
exec() exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组
### RegExp构造函数属性
### 模式的局限性


# Function 类型
由于函数是对象，因此函数名实际上也是一个指向函数对象的指针
### 没有重载
创建第二个函数时，实际上覆盖了引用第一个函数的变量
### 函数声明与函数表达式
解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。
### 作为值的函数

函数可以作为值来只用 也可以作为函数传递的参数
函数也可以作为函数的返回值
### 函数内部属性 
arguments 和 this
    arguments 类数组对象，包含着传入函数中的所有参数这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数
arguments.callee 类似地址值 函数名定义了之后还会改变 但定义的函数的堆内存的地址不变
this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是 window）

 *函数的名字仅仅是一个包含指针的变量而已
 caller 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null
### 函数属性和方法

每个函数都包含两个属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数
每个函数都包含两个非继承而来的方法：apply()和 call()。
apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组
第二个参数可以是 Array 的实例，也可以是arguments 对象

call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数  参数一一列出 不在是数组

* 通过 apply 或 call 可以来改变函数的this指向
bind()  这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值
# 基本包装类型

3 个特殊的引用类型：Boolean、Number 和String。
### Boolean类型
new Boolean () 最好不用 

个人认为是在 堆里面新开一端空间存放 值  然后进行指向 所以定义 var v = new Boolean(false)  v 是有值的 所以 v 为true
### Number类型

为 toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式
toFixed()方法会按照指定的小数位返回数值的字符串

var num = 10; 
alert(num.toFixed(2)); //"10.00"
是 toExponential()，该方法返回以指数表示法（也称 e 表示法）

提交不要使用实例化 在实例化时 和boolean一样 会作为对象 有指向 类型会变为 boject

### String类型

String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符
空格也算一个字符
charAt() 接收一个下标 返回 这个字符
charCodeAt()  接收一个下标 返回 这个字符的字符编码

另一个访问个别字符的方法  alert(stringValue[1])
### 字符串操作方法
是 concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串
concat()方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串

使用更多的还是加号操作符（+） 

直接拼接字符串三个基于子字符串创建新字符串的方法：slice()、substr()和 substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。  均返回新的字符串

### 字符串位置方法

### trim()方法
删除字符串开头和末尾的空格

### 字符串大小写转换方法
toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()

### 字符串的模式匹配方法
是 match()  接收 正则表达式 或者 RegExp 对象
本质上与调用 RegExp 的 exec()方法相同
search() 查找到第一个字符
replace()方法。这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串


### localeCompare()
### fromCharCode()
HTML 方法

# 单体内置对象
 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了

### Global对象
所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。
bal 对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。

##### eval()方法

当解析器发现代码中调用 eval()方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。
严格模式报错

##### window 对象


### Math对象

数学计算中可能会用到的一些特殊值
min()和 max()方法
找出最小  最大的数
舍入方法
Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；
Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；
Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则）。

 random()
 Math.random()方法返回大于等于 0 小于 1 的一个随机数。

# 小结
对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，
现简要总结如下：
 引用类型与传统面向对象程序设计中的类相似，但实现不同；
 Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为；
 Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
 Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
 RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表
达式功能。
函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地
方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类
型分别是：Boolean、Number 和 String。以下是它们共同的特征：
 每个包装类型都映射到同名的基本类型；
 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据
操作；
 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。
在所有代码执行之前，作用域中就已经存在两个内置对象：Global 和 Math。在大多数 ECMAScript
实现中都不能直接访问 Global 对象；不过，Web 浏览器实现了承担该角色的 window 对象。全局变
量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算
任务。
 


























